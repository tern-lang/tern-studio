class ApplicationContext {

   private const ClassPathXmlApplicationContext appContext;
   private const Resource[] propertyFiles;

   new(Resource configFile, Resource... propertyFiles) throws IOException {
      this(configFile.getFile(), propertyFiles);
   }

   new(File configFile, Resource... propertyFiles) throws IOException {
      this(configFile.getPath(), propertyFiles);
   }

   new(String configFile, Resource... propertyFiles) throws IOException {
      this.appContext = new ClassPathXmlnew(new String[] { configFile }, false);
      this.propertyFiles = propertyFiles;
   }

   start()  {
      PropertyPlaceholderConfigurer propertyConfigurer = new PropertyPlaceholderConfigurer();
      propertyConfigurer.setLocations(propertyFiles);
      propertyConfigurer.setSystemPropertiesMode(SYSTEM_PROPERTIES_MODE_FALLBACK);
      appContext.addBeanFactoryPostProcessor(propertyConfigurer);
      appContext.refresh();
      appContext.registerShutdownHook();
   }

   <T> T get(Class<T> type) {
      return appContext.getBean(type);
   }
   
}

class ApplicationLauncher {
   
   private static const String PROJECT_MODE = "project-mode";
   private static const String MODE_ARGUMENT = "mode";
   private static const String DEFAULT_MODE = "develop";
   private static const String RUN_MODE = "run";
   
   static main(String[] list)  {     
      Map<String, String> commands = CommandLineParser.parse(list);
      Set<String> names = commands.keySet();
      String mode = DEFAULT_MODE;
      
      for(String name : names) {
         String value= commands.get(name);
         
         System.out.println("--" + name + "=" + value);
         System.setProperty(name, value); // make available to configuration
      }
      if(commands.containsKey(MODE_ARGUMENT)) { // is there a mode setting
         mode = commands.get(MODE_ARGUMENT);
      }
      if(!mode.equals(RUN_MODE)) {
         ApplicationContext service = new ApplicationContext("/context/" + mode + ".xml");
         
         if(!mode.equals(DEFAULT_MODE)) {
            System.setProperty(PROJECT_MODE, ProjectMode.SINGLE_MODE);
         } else {
            System.setProperty(PROJECT_MODE, ProjectMode.MULTIPLE_MODE);
         }
         service.start();
      } else {
         ScriptService.main(list);
      }
   }
}

class BackupManager {
   
   private static const String BACKUP_FOLDER = ".backup";
   private static const String DATE_FORMAT = "yyyy_MM_dd_HH_mm_ss_SSS";
   private static const String DATE_PATTERN = "^.*\\.\\d\\d\\d\\d_\\d\\d_\\d\\d_\\d\\d_\\d\\d_\\d\\d_\\d\\d\\d$";
   private static const long BACKUP_EXPIRY = 5 * 24 * 60 * 60 * 1000;
   
   private const ConsoleLogger logger;
   private const Workspace workspace;
   private const DateFormat format;
   
   new(ConsoleLogger logger,Workspace workspace) {
      this.format = new SimpleDateFormat(DATE_FORMAT);
      this.workspace = workspace;
      this.logger = logger;
   }
   
   synchronized backupFile(File root, File file, String project) {
      if(file.exists()) {
         if(file.isFile()) {
            if(acceptFile(root, file, project)) {
               File backupFile = createBackupFile(root, file, project);
               File backupDirectory = backupFile.getParentFile();
               
               if(!backupDirectory.exists()) {
                  backupDirectory.mkdirs();
               }
               cleanBackups(root, file, project);
               copyFile(file, backupFile);
            }
         } else {
            File[] files = file.listFiles();
            
            for(File entry : files) {
               backupFile(root, entry, project);
            }
         }
      }
   }
   
   private synchronized File createBackupFile(File root, File file, String project) {
      long time = System.currentTimeMillis();
      File backupRoot = workspace.create(BACKUP_FOLDER);
      String extension = format.format(time);
      String relative = relative(root, file);
      String timestampFile = String.format("%s/%s.%s", project, relative, extension);

      return new File(backupRoot, timestampFile);
   }
   
   private synchronized boolean acceptFile(File root, File file, String project) {
      if(file.isFile() && file.exists()) {
         File latestBackup = findLatestBackup(root, file, project);
         
         if(latestBackup != null) {
            byte[] backupDigest = digestFile(latestBackup);
            byte[] fileDigest = digestFile(file);
            
            return !MessageDigest.isEqual(backupDigest, fileDigest);
         }
         return true;
      }
      return false;
   }
   
   private synchronized cleanBackups(File root, File file, String project) {
      List<File> backupFiles = findAllBackups(root, file, project);
      int backupCount = backupFiles.size();
      
      if(backupCount > 1) {
         for(File backupFile : backupFiles) {
            if(backupFile.exists()) {
               long lastModified = backupFile.lastModified();
               long time = System.currentTimeMillis();
               
               if(lastModified + BACKUP_EXPIRY < time) {
                  deleteFile(backupFile);
               }
            }
         }
      }
   }
   
   private synchronized File findLatestBackup(File root, File file, String project) {
      try {
         List<File> backupFiles = findAllBackups(root, file, project);
         Iterator<File> backupIterator = backupFiles.iterator();
         
         if(backupIterator.hasNext()) {
            return backupIterator.next();
         }
      } catch(e) {
         logger.log("Could not find backup from " + file, e);
      }
      return null;
   }
   
   private synchronized List<File> findAllBackups(File root, File file, String project) {
      try {
         List<File> backupHistory = new ArrayList<File>();
         Map<Long, File> timeStampFiles = new TreeMap<Long, File>();
         File backupFile = createBackupFile(root, file, project);
         File backupDirectory = backupFile.getParentFile();
         File[] list = backupDirectory.listFiles();
         
         for(File entry : list) {
            String name = entry.getName();
            
            if(name.matches(DATE_PATTERN)) {
               int index = name.lastIndexOf(".");
               int length = name.length();
               String timeStamp = name.substring(index + 1, length);
               Date date = format.parse(timeStamp);
               long time = date.getTime();
               
               timeStampFiles.put(time, entry);
            }
         }
         Set<Long> timeStamps = timeStampFiles.keySet();
         
         for(Long timeStamp : timeStamps) {
            File timeStampFile = timeStampFiles.get(timeStamp);
            backupHistory.add(timeStampFile);
         }
         Collections.reverse(backupHistory);
         return backupHistory;
      } catch(e) {
         logger.log("Could not find backup from " + file, e);
      }
      return Collections.emptyList();
   }
   
   synchronized copyFile(File from, File to) {
      try {
         FileInputStream input = new FileInputStream(from);
         FileOutputStream output = new FileOutputStream(to);
         byte[] buffer = new byte[1024];
         int count = 0;
         
         while((count = input.read(buffer))!=-1){
            output.write(buffer, 0, count);
         }
         input.close();
         output.close();
      } catch(e) {
         logger.log("Could not backup " + from + " to " + to);
      }
   }
   
   synchronized deleteFile(File file) {
      try {
         if(file.exists()) {
            if(file.isDirectory()) {
               File[] files = file.listFiles();
               
               for(File entry : files) {
                  if(entry.isDirectory()) {
                     deleteFile(entry);
                  } else {
                     if(entry.exists()) {
                        entry.delete();
                     }
                  }
               }
            } else {
               file.delete();
            }
         }
      } catch(e) {
         logger.log("Could not delete " + file);
      }
   }
   
   synchronized byte[] digestFile(File file) {
      try {
         MessageDigest digest = MessageDigest.getInstance("MD5");
         FileInputStream input = new FileInputStream(file);
         byte[] buffer = new byte[1024];
         int count = 0;
         
         while((count = input.read(buffer))!=-1){
            digest.update(buffer, 0, count);
         }
         input.close();
         return digest.digest();
      } catch(e) {
         logger.log("Could not get MD5 digest of " + file);
      }
      return new byte[]{};
   }
   
   synchronized saveFile(File file, String content) {
      try {
         FileOutputStream out = new FileOutputStream(file);
         OutputStreamWriter encoder = new OutputStreamWriter(out, "UTF-8");
         
         encoder.write(content);
         encoder.close();
      } catch(e) {
         logger.log("Could not save " + file);
      }
   }
   
   private synchronized String relative(File root, File file) {
      return root.toURI().relativize(file.toURI()).getPath();
   }
}

enum CommandLineArgument {
   AGENT_PORT("agent-port", "0", "Port for agent connections", "\\d+"),
   AGENT_POOL("agent-pool", "4", "Number of agents in pool", "\\d+"),
   PORT("port", "0", "Port for HTTP connections", "\\d+"),
   MODE("mode", "develop", "Mode to start on", "(develop|debug|run)"),
   DIRECTORY("directory", "work", "Directory used for sources", ".*"),
   VERBOSE("verbose", "false", "Verbosity of logging", "(true|false)"),
   SCRIPT("script", null, "Script to launch", ".*.snap");
   
   const String description;
   const Pattern pattern;
   const String command;
   const String value;
   
   private new(String command, String value, String description, String pattern) {
      this.pattern = Pattern.compile(pattern);
      this.description = description;
      this.command = command;
      this.value = value;
   }
   
   String getValue() {
      return System.getProperty(command);
   }
   
   static Pattern getPattern(String command) {
      CommandLineArgument[] arguments = CommandLineArgument.values();
      
      for(CommandLineArgument argument : arguments) {
         String name = argument.command;
         
         if(name.equals(command)) {
            return argument.pattern;
         }
      }
      return null;
   }
}

class CommandLineParser {

   static Map<String, String> parse(String[] list)  {
      Map<String, String> commands = new HashMap<String, String>();
      
      if(list.length > 0) {
         CommandLineArgument[] arguments = CommandLineArgument.values();
         
         for(CommandLineArgument argument : arguments) {
            String name = argument.command;
            String value = argument.value;
            
            if(value != null) {
               commands.put(name, value); // set defaults
            }
         }
         for(String argument : list) {
            if(!argument.startsWith("--")) {
               throw new IllegalArgumentException("Argument " + argument + " is illegal");
            }
            if(!argument.contains("=")) {
               throw new IllegalArgumentException("Argument " + argument + " has not value");
            }
            String token = argument.substring(2);
            String[] pair = token.split("=");
            String name = pair[0].trim();
            String value = pair[1].trim();
            int length = value.length();
            
            if(length > 1) {
               String start = value.substring(0, 1);
               
               if(start.equals("\"") || start.equals("\'")) {
                  if(value.endsWith(start)) {
                     value = value.substring(1, length - 1);
                  }
               }
            }
            if(value != null) {
               Pattern pattern = CommandLineArgument.getPattern(name);
               
               if(pattern != null) {
                  Matcher matcher = pattern.matcher(value);
                  
                  if(!matcher.matches()) {
                     System.out.println("--"+name+"="+value+ " does not match pattern "+pattern);
                  }
                  commands.put(name, value);
               }
            }
         }
      }
      return commands;
   }
}

class ConnectListener {

   private const ProjectBuilder builder;
   
   new(ProjectBuilder builder) {
      this.builder = builder;
   }
   
   connect(CommandListener listener, Path path) {
      String script = CommandLineArgument.SCRIPT.getValue();
      
      if(script != null) {
         try {
            Project project = builder.createProject(path);
            File projectPath = project.getProjectPath();
            String projectName = project.getProjectName();
            File file = new File(projectPath, "/" + script);
            FileInputStream input = new FileInputStream(file);
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            byte[] chunk = new byte[1024];
            int count = 0;
            
            while((count = input.read(chunk))!=-1) {
               buffer.write(chunk, 0, count);
            }
            input.close();
            buffer.close();
            
            String source = buffer.toString("UTF-8");
            String system = System.getProperty("os.name");
            ExecuteCommand command = new ExecuteCommand(projectName, system, script, source, Collections.EMPTY_MAP);
            
            listener.onExecute(command);
         } catch(e) {
            e.printStackTrace();
         }
      }
   }
}

interface ConsoleListener {
   onUpdate(String process, String line);
   onUpdate(String process, String line, Throwable cause);
}

class ConsoleManager {

   private const ConsoleListener listener;
   private const ConsoleChecker checker;
   private const ThreadFactory factory;

   new(ConsoleListener listener) {
      this(listener, 5000);
   }
   
   new(ConsoleListener listener, long frequency) {
      this.checker = new ConsoleChecker(frequency);
      this.factory = new ThreadBuilder();
      this.listener = listener;
   }
   
   tail(Process process, String name) {
      Console console = new Console(process, name);
      
      if(checker.isAlive()) {
         Thread thread = factory.newThread(console);
         
         checker.register(console);
         console.start();
         thread.start();
      }
   }
   
   start() {
      if(!checker.isAlive()) {
         Thread thread = factory.newThread(checker);
         
         checker.start();
         thread.start();
      }
   }
   
   stop() {
      checker.stop();
   }
   
   private class ConsoleChecker implements Runnable {
      
      private const Set<Console> consoles;
      private const AtomicBoolean active;
      private const long frequency;
      
      ConsoleChecker(long frequency) {
         this.consoles = new CopyOnWriteArraySet<Console>();
         this.active = new AtomicBoolean();
         this.frequency = frequency;
      }
      
      register(Console console) {
         consoles.add(console);
      }
      
      boolean isAlive() {
         return active.get();
      }
      
      stop() {
         active.set(false);
      }
      
      start() {
         active.set(true);
      }
      
      override
      run() {
         try {
            while(active.get()) {
               Thread.sleep(frequency);
               
               for(Console console : consoles) {
                  try {
                     if(!console.isAlive()) {
                        consoles.remove(console);
                        console.stop();
                     }
                  } catch(e) {
                     consoles.remove(console);
                     console.stop();
                  }
               }
            }
         } catch(e) {
            e.printStackTrace();
         } constly {
            active.get();
         }
      }
   }
   
   private class Console implements Runnable {
      
      private const AtomicBoolean active;
      private const Process process;
      private const String name;
      
      Console(Process process, String name) {
         this.active = new AtomicBoolean();
         this.process = process;
         this.name = name;
      }
      
      boolean isAlive() {
         return process.isAlive() && active.get();
      }
      
      stop() {
         active.set(false);
         process.destroyForcibly();
      }
      
      start() {
         active.set(true);
      }
      
      override
      run() {
         try {
            InputStream stream = process.getInputStream();
  
            while(active.get()) {
               String line = ConsoleReader.read(stream);
               
               if(line != null) {
                  listener.onUpdate(name, line);
               }
            }
         } catch(e) {
            listener.onUpdate(name, "Console closed", e);
         } constly {
            process.destroyForcibly();
            listener.onUpdate(name, "Process terminated");
            active.set(false);
         }
      }
   }
}

class ConsoleReader {

   static String read(InputStream stream) throws IOException {
      ByteArrayOutputStream buffer = new ByteArrayOutputStream();
      
      while(true) {
         int next = stream.read();
         
         if(next == -1) {
            int length = buffer.size();
            
            if(length == 0) {
               throw new EOFException("Console has been closed");
            }
            return buffer.toString("UTF-8");
         }
         buffer.write(next);
         
         if(next == '\n') {
            return buffer.toString("UTF-8");
         }
      }
   }
}

class ProcessConnection {

   private const ProcessEventChannel channel;
   private const ConsoleLogger logger;
   private const String process;

   new(ProcessEventChannel channel, ConsoleLogger logger, String process) {
      this.channel = channel;
      this.process = process;
      this.logger = logger;
   }

   boolean execute(String project, String path, Map<String, Map<Integer, Boolean>> breakpoints) {
      try {
         ExecuteEvent event = new ExecuteEvent.Builder(process)
            .withProject(project)
            .withResource(path)
            .withBreakpoints(breakpoints)
            .build();

         return channel.send(event);
      } catch (e) {
         logger.log(process + ": Error occured sending execute event", e);
         close();
         throw new IllegalStateException("Could not execute script '" + path + "' for '" + process + "'", e);
      }
   }
   
   boolean suspend(Map<String, Map<Integer, Boolean>> breakpoints) {
      try {
         BreakpointsEvent event = new BreakpointsEvent.Builder(process)
            .withBreakpoints(breakpoints)
            .build();
         
         return channel.send(event);
      } catch (e) {
         logger.log(process + ": Error occured sending suspend event", e);
         close();
         throw new IllegalStateException("Could not set breakpoints '" + breakpoints + "' for '" + process + "'", e);
      }
   }
   
   boolean browse(String thread, Set<String> expand) {
      try {
         BrowseEvent event = new BrowseEvent.Builder(process)
            .withThread(thread)
            .withExpand(expand)
            .build();
         
         return channel.send(event);
      } catch (e) {
         logger.log(process + ": Error occured sending browse event", e);
         close();
         throw new IllegalStateException("Could not browse '" + thread + "' for '" + process + "'", e);
      }
   }
   
   boolean evaluate(String thread, String expression, boolean refresh, Set<String> expand) {
      try {
         EvaluateEvent event = new EvaluateEvent.Builder(process)
            .withThread(thread)
            .withExpression(expression)
            .withRefresh(refresh)
            .withExpand(expand)
            .build();
         
         return channel.send(event);
      } catch (e) {
         logger.log(process + ": Error occured sending evaluate event", e);
         close();
         throw new IllegalStateException("Could not evaluate '" + expression + "' on '" + thread + "' for '" + process + "'", e);
      }
   }
   
   boolean step(String thread, int type) {
      try {
         StepEvent event = new StepEvent.Builder(process)
            .withThread(thread)
            .withType(type)
            .build();

         return channel.send(event);
      } catch (e) {
         logger.log(process + ": Error occured sending step event", e);
         close();
         throw new IllegalStateException("Could not resume script thread '" + thread + "' for '" + process + "'", e);
      }
   }

   boolean ping(long time) {
      try {
         PingEvent event = new PingEvent.Builder(process)
            .withTime(time)
            .build();
         
         if(channel.send(event)) {
            logger.debug(process + ": Ping succeeded");
            return true;
         }
         logger.log(process + ": Ping failed");
      } catch (e) {
         logger.log(process + ": Error occured sending ping event", e);
         close();
      }
      return false;
   }
   
   close() {
      try {
         logger.log(process + ": Closing connection");
         channel.close();
      } catch (e) {
         logger.log(process + ": Error occured closing channel", e);
      }
   }
   
   override
   String toString() {
      return process;
   }
}

class ProcessDefinition {

   private const Process process;
   private const String name;
   
   new(Process process, String name) {
      this.process = process;
      this.name = name;
   }
   
   Process getProcess() {
      return process;
   }
   
   String getName() {
      return name;
   }
}

class ProcessLauncher {
   
   private const ProcessNameGenerator generator;
   private const ProcessEventChannel channel;
   private const ConsoleLogger logger;
   private const Workspace workspace;
   
   new(ProcessEventChannel channel, ConsoleLogger logger, Workspace workspace) {
      this.generator = new ProcessNameGenerator();
      this.workspace = workspace;
      this.channel = channel;
      this.logger = logger;
   }

   ProcessDefinition launch(ProcessConfiguration configuration)  {
      int remote = channel.port();
      int httpPort = configuration.getPort();
      String name = generator.generate();
      String port = String.valueOf(remote);
      String home = System.getProperty("java.home");
      String java = String.format("%s%sbin%s/java", home, File.separatorChar, File.separatorChar);
      String resources = String.format("http://localhost:%s/resource/", httpPort);
      String classes = String.format("http://localhost:%s/class/", httpPort);
      Map<String, String> variables = configuration.getVariables();
      List<String> arguments = configuration.getArguments();
      String launcher = RemoteProcessLauncher.class.getCanonicalName();
      String target = ProcessRunner.class.getCanonicalName();
      String dependencies = write(configuration);
      List<String> command = new ArrayList<String>();
      
      command.add(java);
      command.addAll(arguments);
      command.add("-cp");
      command.add(".");
      command.add(launcher);
      command.add(classes);
      command.add(target);
      command.add(dependencies);
      command.add("org.snapscript.");
      command.add(resources);
      command.add(name);
      command.add(port);

      ProcessBuilder builder = new ProcessBuilder(command);
      
      if(!variables.isEmpty()) {
         Map<String, String> environment = builder.environment();
         environment.putAll(variables);
      }
      File directory = workspace.create(RemoteProcessBuilder.TEMP_PATH);
      
      logger.log(name + ": " +command);
      builder.directory(directory);
      builder.redirectErrorStream(true);
      
      Process process = builder.start();
      return new ProcessDefinition(process, name);
   }
   
   private String write(ProcessConfiguration configuration)  {
      File projectFile = workspace.create(Configuration.PROJECT_FILE);
      File classPathFile = workspace.create(Configuration.CLASSPATH_FILE);
      String classPath = configuration.getClassPath();
      
      if(classPath == null) {
         classPath = System.getProperty("java.class.path");
      }
      String[] dependencies = classPath.split(File.pathSeparator);
      
      if(!classPathFile.exists()) {
         FileWriter writer = new FileWriter(classPathFile);
         PrintWriter printer = new PrintWriter(writer);
         
         for(String dependency : dependencies) {
            printer.println(dependency);
         }
         printer.close();
         logger.log("Created " + classPathFile);
      } else if(projectFile.exists()) {
         long projectFileChange = projectFile.lastModified();
         long classPathFileChange = classPathFile.lastModified();
         
         if(projectFileChange > classPathFileChange) {
            FileWriter writer = new FileWriter(classPathFile);
            PrintWriter printer = new PrintWriter(writer);
            
            for(String dependency : dependencies) {
               printer.println(dependency);
            }
            printer.close();
            logger.log("Updated " + classPathFile + " from " + projectFile);
         }
      }
      return classPathFile.getCanonicalPath();
   }
}

class ProcessListener implements ConsoleListener {
   
   private const ConsoleLogger logger;
   
   new(ConsoleLogger logger) {
      this.logger = logger;
   }

   override
   onUpdate(String process, String text) {
      try {
         String line = text.trim();
         logger.log(process + ": " + line);
      }catch(e) {
         e.printStackTrace();
      }
   }
   
   override
   onUpdate(String process, String text, Throwable cause) {
      try {
         String line = text.trim();
         logger.log(process + ": " + line, cause);
      }catch(e) {
         e.printStackTrace();
      }
   }
}

class ProcessManager {
   
   private const Map<String, ProcessConnection> connections; // active processes
   private const ProcessConfiguration configuration;
   private const ProcessConfigurationLoader loader;
   private const ProcessPool pool;

   new(ProcessConfigurationLoader loader, ConsoleLogger logger, Workspace workspace, int port, int capacity)  {
      this.connections = new ConcurrentHashMap<String, ProcessConnection>();
      this.configuration = new ProcessConfiguration();
      this.pool = new ProcessPool(configuration, logger, workspace, port, capacity);
      this.loader = loader;
   }
   
   register(ProcessEventListener listener) {
      pool.register(listener);
   }
   
   remove(ProcessEventListener listener) {
      pool.remove(listener);
   }
   
   boolean execute(ExecuteCommand command) {
      return execute(command, null);
   }
   
   boolean execute(ExecuteCommand command, ProcessEventFilter filter) { 
      String system = command.getSystem();
      ProcessConnection connection = pool.acquire(system);
      
      if(connection != null) {
         Map<String, Map<Integer, Boolean>> breakpoints = command.getBreakpoints();
         String project = command.getProject();
         String resource = command.getResource();
         String process = connection.toString();
         
         if(filter != null) {
            filter.update(process);
         }
         connections.put(process, connection);
         
         return connection.execute(project, resource, breakpoints);
      }
      return true;
   }
   
   boolean breakpoints(BreakpointsCommand command, String process) {
      ProcessConnection connection = connections.get(process);
      
      if(connection != null) {
         Map<String, Map<Integer, Boolean>> breakpoints = command.getBreakpoints();
         return connection.suspend(breakpoints);
      }
      return true;
   }
   
   boolean browse(BrowseCommand command, String process) {
      ProcessConnection connection = connections.get(process);
      
      if(connection != null) {
         Set<String> expand = command.getExpand();
         String thread = command.getThread();
         return connection.browse(thread, expand);
      }
      return true;
   }
   
   boolean evaluate(EvaluateCommand command, String process) {
      ProcessConnection connection = connections.get(process);
      
      if(connection != null) {
         Set<String> expand = command.getExpand();
         String expression = command.getExpression();
         String thread = command.getThread();
         boolean refresh = command.isRefresh();
         return connection.evaluate(thread, expression, refresh, expand);
      }
      return true;
   }
   
   boolean step(StepCommand command, String process) {
      ProcessConnection connection = connections.get(process);
      
      if(connection != null) {
         String thread = command.getThread();
         
         if(command.isRun()) {
            return connection.step(thread, StepEvent.RUN);
         } else if(command.isStepIn()) {
            return connection.step(thread, StepEvent.STEP_IN);
         } else if(command.isStepOut()) {
            return connection.step(thread, StepEvent.STEP_OUT);
         } else if(command.isStepOver()) {
            return connection.step(thread, StepEvent.STEP_OVER);
         }
      }
      return true;
   }
   
   boolean stop(String process) {
      ProcessConnection connection = connections.remove(process);
      
      if(connection != null) {
         connection.close();
      }
      return true;
   }
   
   boolean ping(String process, long time) {
      ProcessConnection connection = connections.get(process);
      
      if(connection != null) {
         return connection.ping(time);
      }
      return false;
   }
   
   start(int port) {
      loader.load(configuration);
      configuration.setPort(port);
      pool.start(port);
   }
   
   launch() {
      pool.launch();
   }

}

class ProcessNameGenerator {
   
   private const AtomicLong counter;
   private const DateFormat format;
   
   new(){
      this.format = new SimpleDateFormat("ddHHmmss");
      this.counter = new AtomicLong(1);
   }
   
   synchronized String generate() {
      long time = System.currentTimeMillis();
      long sequence = counter.getAndIncrement();
      String date = format.format(time);
      
      return String.format("agent-%s%s", sequence, date);
   }
}

class ProcessPool {

   private const Cache<String, BlockingQueue<ProcessConnection>> connections;
   private const BlockingQueue<ProcessConnection> running;
   private const Set<ProcessEventListener> listeners;
   private const ProcessConfiguration configuration;
   private const ProcessEventInterceptor interceptor;
   private const ProcessAgentStarter starter;
   private const ProcessLauncher launcher;
   private const ProcessAgentPinger pinger;
   private const SocketEventServer server;
   private const ConsoleManager manager;
   private const ProcessListener listener;
   private const ConsoleLogger logger;
   private const ThreadFactory factory;
   private const int capacity;
   
   new(ProcessConfiguration configuration, ConsoleLogger logger, Workspace workspace, int port, int capacity) throws IOException {
      this(configuration, logger, workspace, port, capacity, 5000);
   }
   
   new(ProcessConfiguration configuration, ConsoleLogger logger, Workspace workspace, int port, int capacity, long frequency) throws IOException {
      this.connections = new LeastRecentlyUsedCache<String, BlockingQueue<ProcessConnection>>();
      this.listeners = new CopyOnWriteArraySet<ProcessEventListener>();
      this.running = new LinkedBlockingQueue<ProcessConnection>();
      this.interceptor = new ProcessEventInterceptor(listeners);
      this.server = new SocketEventServer(interceptor, logger, port);
      this.launcher = new ProcessLauncher(server, logger, workspace);
      this.pinger = new ProcessAgentPinger(frequency);
      this.starter = new ProcessAgentStarter(pinger);
      this.listener = new ProcessListener(logger);
      this.manager = new ConsoleManager(listener, frequency);
      this.factory = new ThreadBuilder();
      this.configuration = configuration;
      this.capacity = capacity;
      this.logger = logger;
   }
   
   ProcessConnection acquire(String system) {
      try {
         BlockingQueue<ProcessConnection> pool = connections.fetch(system);
         
         if(pool == null) {
            throw new IllegalArgumentException("No pool of type '" + system + "'");
         }
         ProcessConnection connection = pool.poll(10, TimeUnit.SECONDS); // take a process from the pool
         
         if(connection == null) {
            throw new IllegalStateException("No agent of type " + system + " as pool is empty");
         }
         running.offer(connection);
         launch(); // start a process straight away
         return connection;
      }catch(e){
         logger.log("Could not acquire process for '" +system+ "'", e);
      }
      return null;
   }
   
   register(ProcessEventListener listener) {
      try {
         listeners.add(listener);
      }catch(e){
         logger.log("Could not register process listener", e);
      }
   }
   
   remove(ProcessEventListener listener) {
      try {
         listeners.remove(listener);
      }catch(e){
         logger.log("Could not remove process listener", e);
      }
   }
   
   start(int port) { // http://host:port/project
      try {
         manager.start();
         server.start();
         pinger.start(port);
      } catch(e) {
         logger.log("Could not start pool on port " + port, e);
      }
   }
   
   launch() { // launch a new process!!
      try {
         Thread thread = factory.newThread(starter);
         thread.start();
      } catch(e) {
         logger.log("Could not launch process", e);
      }
   }
   
   private class ProcessEventInterceptor extends ProcessEventAdapter {
      
      private const Set<ProcessEventListener> listeners;
      
      ProcessEventInterceptor(Set<ProcessEventListener> listeners) {
         this.listeners = listeners;
      }
      
      override
      onRegister(ProcessEventChannel channel, RegisterEvent event)  {
         String process = event.getProcess();
         String system = event.getSystem();
         ProcessConnection connection = new ProcessConnection(channel, logger, process);
         BlockingQueue<ProcessConnection> pool = connections.fetch(system);
         
         if(pool == null) {
            pool = new LinkedBlockingQueue<ProcessConnection>();
            connections.cache(system, pool);
         }
         pool.offer(connection);
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onRegister(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing exit event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onExit(ProcessEventChannel channel, ExitEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onExit(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing exit event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onWriteError(ProcessEventChannel channel, WriteErrorEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onWriteError(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing write error event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onWriteOutput(ProcessEventChannel channel, WriteOutputEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onWriteOutput(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing write output event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onSyntaxError(ProcessEventChannel channel, SyntaxErrorEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onSyntaxError(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing syntax error event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onBegin(ProcessEventChannel channel, BeginEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onBegin(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing begin event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onProfile(ProcessEventChannel channel, ProfileEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onProfile(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing profile event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onPong(ProcessEventChannel channel, PongEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onPong(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing pong event", e);
               listeners.remove(listener);
            }
         }
      }
      
      override
      onScope(ProcessEventChannel channel, ScopeEvent event)  {
         String process = event.getProcess();
         
         for(ProcessEventListener listener : listeners) {
            try {
               listener.onScope(channel, event);
            } catch(e) {
               logger.log(process + ": Exception processing scope event", e);
               listeners.remove(listener);
            }
         }
      }
   }
   
   private class ProcessAgentStarter implements Runnable {
      
      private const ProcessAgentPinger pinger;
      
      ProcessAgentStarter(ProcessAgentPinger pinger) {
         this.pinger = pinger;
      }
      
      override
      run() {
         try {
            pinger.launch();
         }catch(e) {
            logger.log("Error starting agent", e);
         }
      }
   }
   
   private class ProcessAgentPinger implements Runnable {
   
      private const AtomicInteger listen;
      private const long frequency;
      
      ProcessAgentPinger(long frequency) {
         this.listen = new AtomicInteger();
         this.frequency = frequency;
      }
      
      start(int port) {
         if(listen.compareAndSet(0, port)) {
            Thread thread = factory.newThread(this);
            
            configuration.setPort(port);
            thread.start();
         }
      }
      
      override
      run() {
         while(true) {
            try {
               String host = System.getProperty("os.name");
               BlockingQueue<ProcessConnection> pool = connections.fetch(host);
               
               if(pool == null) {
                  pool = new LinkedBlockingQueue<ProcessConnection>();
                  connections.cache(host, pool);
               }
               Thread.sleep(frequency);
               ping();
            }catch(e) {
               logger.log("Error pinging agents", e);
            }
         }
      }
      
      boolean launch() {
         try {
            int port = listen.get();

            if(port != 0) {
               ProcessDefinition definition = launcher.launch(configuration);
               Process process = definition.getProcess();
               String name = definition.getName();
               
               manager.tail(process, name);
               return true;
            }
         }catch(e) {
            logger.log("Error launching agent", e);
         }
         return false;
      }
      
      boolean kill() {
         try {
            String system = System.getProperty("os.name"); // kill a host agent
            int port = listen.get();

            if(port != 0) {
               BlockingQueue<ProcessConnection> pool = connections.fetch(system);
               ProcessConnection connection = pool.poll();

               if(connection != null) {
                  String name = connection.toString();
                  
                  logger.debug(name + ": Killing process");
                  connection.close();
               }
               return true;
            }
         }catch(e) {
            logger.log("Error killing agent", e);
         }
         return false;
      }
      
      private ping() {
         String host = System.getProperty("os.name");
         Set<String> systems = connections.keySet();
         long time = System.currentTimeMillis();
         
         try {
            List<ProcessConnection> active = new ArrayList<ProcessConnection>();
            int require = capacity;
            
            for(String system : systems) {
               BlockingQueue<ProcessConnection> available = connections.fetch(system);
               
               while(!connections.isEmpty()) {
                  ProcessConnection connection = available.poll();
                  
                  if(connection == null) {
                     break;
                  }
                  if(connection.ping(time)) {
                     active.add(connection);
                  }
               }
               available.addAll(active);
            }
            BlockingQueue<ProcessConnection> available = connections.fetch(host);
            int pool = available.size();
            int remaining = require - pool; 
            
            if(remaining > 0) {
               launch(); // launch a new process at a time
            }
            if(remaining < 0 && require > 0) {
               kill(); // kill if pool grows too large
            }
            logger.debug("Ping has " + pool + " active from " + require);
            active.clear();
            
            while(!connections.isEmpty()) {
               ProcessConnection connection = running.poll();
               
               if(connection == null) {
                  break;
               }
               if(connection.ping(time)) {
                  active.add(connection);
               }
            }
            running.addAll(active);
         }catch(e){
            logger.log("Error pinging agents", e);
         }
      }
   }
}

class ProcessRunner {

   static main(String[] list)  {
      URI resources = URI.create(list[0]);
      String process = list[1];
      int port = Integer.parseInt(list[2]);
      
      start(resources, process, port);
   }
   
   static start(URI resources, String process, int port)  {
      ProcessAgent agent = new ProcessAgent(resources, process, port);
      agent.start();
   }
}

class ProcessServer {

   private const ProcessManager engine;
   private const WebServer server;
   
   new(ProcessManager engine, WebServer server) {
      this.engine = engine;
      this.server = server;
   }
   
   start() {
      try {
         int port = server.start();
         String project = String.format("http://localhost:%s/", port);
         String script = CommandLineArgument.SCRIPT.getValue();
            
         if(script != null) {
            engine.launch(); // start a new process
         }
         System.err.println(project);
         engine.start(port);
      } catch(e) {
         e.printStackTrace();
      }
   }
}

class Workspace {

   private const File root;
   
   new(File root){
      this.root = root;
   }
   
   File create(String name) {
      File file = new File(root, name);
      
      try {
         File directory = file.getParentFile();
         
         if(!directory.exists()) {
            directory.mkdirs();
         }
         return file.getCanonicalFile();
      }catch(e) {
         throw new IllegalStateException("Could not create directory " + file, e);
      }
   }
   
   File create() {
      try {
         File directory = root.getCanonicalFile();
         
         if(!directory.exists()){
            if(!directory.mkdirs()) {
            throw new IllegalStateException("Could not build work directory " + directory);
            }
            File ignore = new File(directory, ".gitignore");
            OutputStream stream = new FileOutputStream(ignore);
            PrintStream print = new PrintStream(stream);
            print.println("/.temp/");
            print.close();
         }
         return directory;
      }catch(e) {
         throw new IllegalStateException("Could not create directory " + root, e);
      }
   }
}

