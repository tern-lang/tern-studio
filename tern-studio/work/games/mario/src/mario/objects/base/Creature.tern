import mario.core.GameRenderer;
import mario.core.animation.{CollidableObject, Sprite};
import mario.objects.creatures.RedShell;

class Creature extends CollidableObject {

   public static let xCollideOffset = 2; 
   public static let offMapOffset = 15;
   public static let GRAVITY = 0.0008f;
   public static let gravityEffect = 0.22f; 

   // Wake up values are constants based on the number of tiles on the screen
   // that are used to determine when mario comes within range of a creature.
   // Used exclusively within GameRender.
   public static WAKE_UP_VALUE_DOWN_RIGHT = 24;
   public static WAKE_UP_VALUE_UP_LEFT = -3;

   /* 
   * Creature Attributes:
   * 
   * Relevant:  A creature that is always relevant must be updated every frame. By default, no creature
   *            is always relevant. 
   * Alive:     A creature that is on the map is alive. All creatures start alive and can be killed using
   *            the kill() method.
   * Sleeping:  A creature that is sleeping has yet to be seen by the player. All creatures start out
   *            sleeping, and can be woken up using wakeUp(). They cannot be put back to sleep.
   * Flipped:   isFlipped is a flag used to determine when to change the animation of a creature to death.
   *            For example, a goomba that is hopped on is 'flipped', then removed from the game.
   * Item:      A creature that is an item represents an item the player can interact with.
   * Platform:  A creature is a platform if it is a non-aligned moving object the player
   *            and creatures can interact with. 
   * Invisible a creature is invisible, it isn't drawn.
   */
   private let isAlwaysRelevant = false; 
   private let isAlive = false; 
   private let isSleeping = false; 
   private let isFlipped = false;
   private let isItem = false;
   private let isPlatform = false;
   private let isInvisible = false;

   public new(): this(0, 0, null) { 

   }

   public new(pixelX, pixelY): this(pixelX, pixelY, null) {
   }

   /**
   * @effects Creates a new Creature at the given pixelX, pixelY position that is capable
   * of producing sounds from the soundManager. 
   * 
   * True, Alive, Sleeping, Flipped.
   * False, Item, Platform, Relevant.
   */
   public new(pixelX, pixelY, soundManager): super(pixelX, pixelY, soundManager) {
      setIsCollidable(true);
      isAlive = true;
      isSleeping = true;
      isFlipped = false;
      setIsOnScreen(false);
      isItem = false;
      isPlatform = false;
      isAlwaysRelevant = false;
   }

   /**
   * @return true if this creature is a Platform, false otherwise.
   */
   public isPlatform() {
      return isPlatform;
   }

   /**
   * @modifies the platform status of this Creature.
   */
   public setIsPlatform(isPlatform) {
      this.isPlatform = isPlatform;
   }

   /**
   * @return true if this creature is an Item, false otherwise.
   */
   public isItem() {
      return isItem;
   }

   /**
   * @modifies the item status of this Creature.
   */
   public setIsItem(isItem) {
      this.isItem = isItem;
   }

   /**
   * @return true if this creature is flipped, false otherwise.
   */
   public isFlipped() {
      return isFlipped;
   }

   /**
   * @modifies the flipped status of this Creature.
   */
   public setIsFlipped(isFlipped) {
      this.isFlipped = isFlipped;
   }

   /**
   * @return true if this creature is sleeping, false otherwise.
   */
   public isSleeping() {
      return isSleeping;
   }

   /**
   * @modifies the sleeping status of this creature to false.
   */
   public wakeUp() { 
      isSleeping = false;
   }

   /**
   * @return true if this creature is alive, false otherwise.
   */
   public isAlive() {
      return isAlive;
   }

   /**
   * @modifies the life state of this creature (alive or dead) to dead.
   */
   public kill() {
      isAlive = false;
   }

   /**
   * @return true if this creature is a Platform, false otherwise.
   */
   public isAlwaysRelevant() {
      return isAlwaysRelevant;
   }

   /**
   * @modifies the platform status of this Creature.
   */
   public setIsAlwaysRelevant(isAlwaysRelevant) {
      this.isAlwaysRelevant = isAlwaysRelevant;
   }

   /**
   * @return true if this creature is invisible, false otherwise.
   */
   public isInvisible() {
      return isInvisible;
   }

   /**
   * @modifies the invisible status of this Creature.
   */
   public setIsInvisible(isInvisible) {
      this.isInvisible = isInvisible;
   }

   public jumpedOn() { }
   public flip() { }

   // for tile collisions
   public xCollide(p) {
      if(dx > 0) {
         x = x - xCollideOffset;
      } else {
         x = x + xCollideOffset;
      }
      dx = -dx;
   }

   // for creature collisions
   public creatureXCollide() {
      if(dx > 0) {
         x = x - xCollideOffset;
      } else {
         x = x + xCollideOffset;
      }
      dx = -dx;
   }

   /**
   * Calculates the type of collision in the X direction between a Tile 
   * and a Sprite given the Sprite is currentely colliding with the tile. 
   * This method relies on the general heuristic that if two 
   * rectangular objects are colliding, then one object is not completely
   * contained in the other. Because the colliding objects stick out, we
   * know the direction of the collision. 
   * 
   * pre-condition: sprite is colliding with tile.
   * @return Collision.WEST if sprite is colliding with the tile from the west or
   * Collision.EAST if sprite is colliding with the tile from the east.
   */
   public static tileCollisionX(tile, s) {
      if(s.getX() > tile.getPixelX()) {
         return Collision.WEST;
      } else {
         return Collision.EAST;
      }
   }

   /**
   * Calculates the type of collision in the Y direction between a Tile 
   * and a Sprite given the Sprite is currentely colliding with the tile. 
   * This method relies on the general heuristic that if two 
   * rectangular objects are colliding, that one object is not completely
   * contained in the other. Because the colliding objects stick out, we
   * know the direction of the collision. 
   * 
   * pre-condition: sprite is colliding with tile.
   * @return Collision.NORTH if sprite is colliding with the tile from the north or
   * Collision.SOUTH if sprite is colliding with the tile from the south.
   */
   public static tileCollisionY(tile, s) {
      if(s.getY() < tile.getPixelY()) {
         return Collision.NORTH;
      } else {
         return Collision.SOUTH;
      }
   }

   public updateCreature(map, time) {

      if(dy < gravityEffect) { // apply gravity...this must be done first
         dy = dy + GRAVITY * time;
      }

      let dx = this.dx;
      let oldX = this.x;
      let newX = oldX + dx * time;

      let dy = this.dy;
      let oldY = this.y;
      let newY = oldY + dy * time; 

      if(!isFlipped) {
         let xTile = GameRenderer.getTileCollision(map, this, x, y, newX, y);
         let yTile = GameRenderer.getTileCollision(map, this, x, y, x, newY);

         this.update(time);

         // Update collisions in the x-direction.
         if(oldX < -offMapOffset || oldX > GameRenderer.tilesToPixels(map.getWidth()) + offMapOffset) { // offscreen
            kill();
         } else {
            if(xTile == null) {
               x = newX;
            } else {
               if(!xTile.equals(yTile)) { // Only manage x-collisions that are not y-collisions
                  this.xCollide(xTile);
                  if(dx > 0) {
                     x = GameRenderer.tilesToPixels(xTile.x) - this.getWidth();
                  } else if (dx < 0) {
                     x = GameRenderer.tilesToPixels(xTile.x + 1);
                  }
               }
            }
         }

         // Update collisions in the y-direction. 
         if(oldY > GameRenderer.tilesToPixels(map.getHeight()) + offMapOffset) { // offscreen
            kill();
         } else {
            if(yTile == null) {
               y = newY;
            } else {
               if(dy > 0) {
                  // mark this creature as colliding with a tile
                  map.getTile(yTile.x, yTile.y).collidingCreatures().add(this); 
                  let tileRight = map.getTile(yTile.getX() + 1, yTile.getY());
                  if(tileRight != null) {
                     tileRight.collidingCreatures().add(this);
                  }
                  y = GameRenderer.tilesToPixels(yTile.y) - this.getHeight();
               } else if (dy < 0) {
                  y = GameRenderer.tilesToPixels(yTile.y + 1);
                  this.dy = -dy/4; // fall faster if a collision occured
               } 
            }
         }
      } else { // flipped
         x = newX;
         y = newY;
         this.update(time);
      }
   }

   // Determines what happens when two different creatures collide.
   // Uncommenting the onSreen condition makes this more efficient, but more buggy
   public creatureCollision(creature) {
      if(!this.isItem && !creature.isItem && !this.isPlatform && !creature.isPlatform &&
            this != creature && this.isCollidable() && creature.isCollidable()) {

         let collision = isCollision(this, creature);
         if(collision) {   
            // Handeling RedShell collision cases....
            // ______________________________________
            // creature 1 is a RedShell, creature 2 is not.
            if(this instanceof RedShell && creature !instanceof RedShell) {
               if(this!.isMoving()) {
                  creature.flip();
                  soundManager.playKick();
               }
            // creature 2 is a RedShell, creature 1 is not.
            } else if(this !instanceof RedShell && creature instanceof RedShell) {
               if(creature.isMoving()) {
                  this.flip();
                  soundManager.playKick();
               }
            // both creature 1 and creature 2 are RedShells
            } else if(this instanceof RedShell && creature instanceof RedShell) {
               //RedShell 1 is moving, RedShell 2 is not.
               this.flip();
               creature.flip();
               soundManager.playKick();
            // End of RedShell collision cases...
            //____________________________________________

            } else {
               this.creatureXCollide();
               creature.creatureXCollide();
            }
         }
      }
   }
}
