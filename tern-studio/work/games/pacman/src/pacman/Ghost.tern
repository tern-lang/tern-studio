import util.{HashSet, Set};

/* Ghost class controls the ghost. */
class Ghost extends Mover {
   /* Direction ghost is heading */
   let direction: Character;

   /* Last ghost location */
   let lastX: Integer = 0;
   let lastY: Integer = 0;

   /* Current ghost location */
   let x: Integer = 0;
   let y: Integer = 0;

   /* The pellet the ghost is on top of */
   let pelletX: Integer = 0; 
   let pelletY: Integer = 0;

   /* The pellet the ghost was last on top of */
   let lastPelletX: Integer = 0;
   let lastPelletY: Integer = 0;

   /* Constructor places ghost and updates states */
   public new(x: Integer, y: Integer) {
      this.direction = 'L';
      this.pelletX = x / gridSize - 1;
      this.pelletY = x / gridSize - 1;
      this.lastPelletX = pelletX;
      this.lastPelletY = pelletY;
      this.lastX = x;
      this.lastY = y;
      this.x = x;
      this.y = y;
   }

   /* update pellet status */
   public updatePellet() {
      let tempX, tempY;
      tempX = x / gridSize - 1;
      tempY = y / gridSize - 1;
      if (tempX != pelletX || tempY != pelletY) {
         lastPelletX = pelletX;
         lastPelletY = pelletY;
         pelletX = tempX;
         pelletY = tempY;
      }

   }

   /*
   * Determines if the location is one where the ghost has to make a decision
   */
   public isChoiceDest(): Boolean {
      if (x % gridSize == 0 && y % gridSize == 0) {
         return true;
      }
      return false;
   }

   /* Chooses a new direction randomly for the ghost to move */
   public newDirection(): Character {
      let random: Integer = 0;
      let backwards: Character = 'U';
      let newX: Integer = x, newY = y;
      let lookX: Integer = x, lookY = y;
      let set: Set = new HashSet();
      switch (direction) {
      case 'L':
         backwards = 'R';
         break;
      case 'R':
         backwards = 'L';
         break;
      case 'U':
         backwards = 'D';
         break;
      case 'D':
         backwards = 'U';
         break;
      }

      let newDirection: Character = backwards;
      /* While we still haven't found a valid direction */
      while (newDirection == backwards || !isValidDest(lookX, lookY)) {
         /* If we've tried every location, turn around and break the loop */
         if (set.size() == 3) {
            newDirection = backwards;
            break;
         }

         newX = x;
         newY = y;
         lookX = x;
         lookY = y;

         /* Randomly choose a direction */
         random = Math.floor((Math.random() * 4) + 1);
         if (random == 1) {
            newDirection = 'L';
            newX -= increment;
            lookX -= increment;
         } else if (random == 2) {
            newDirection = 'R';
            newX += increment;
            lookX += gridSize;
         } else if (random == 3) {
            newDirection = 'U';
            newY -= increment;
            lookY -= increment;
         } else if (random == 4) {
            newDirection = 'D';
            newY += increment;
            lookY += gridSize;
         }
         if (newDirection != backwards) {
            set.add(new Character(newDirection));
         }
      }
      return newDirection;
   }

   /* Random move function for ghost */
   public move() {
      lastX = x;
      lastY = y;

      /* If we can make a decision, pick a new direction randomly */
      if (isChoiceDest()) {
         direction = newDirection();
      }

      /* If that direction is valid, move that way */
      switch (direction) {
      case 'L':
         if (isValidDest(x - increment, y))
            x -= increment;
         break;
      case 'R':
         if (isValidDest(x + gridSize, y))
            x += increment;
         break;
      case 'U':
         if (isValidDest(x, y - increment))
            y -= increment;
         break;
      case 'D':
         if (isValidDest(x, y + gridSize))
            y += increment;
         break;
      }
   }
}
