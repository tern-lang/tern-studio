import awt.Point;
import awt.Point;
import awt.Point;
import awt.event.KeyEvent;
import awt.event.KeyListener;
import awt.Canvas;
import awt.Color;
import awt.Dimension;
import awt.Font;
import awt.Graphics;
import awt.Graphics2D;
import awt.Point;
import awt.event.WindowAdapter;
import awt.event.WindowEvent;
import awt.image.BufferStrategy;
import swing.JFrame;
import swing.JPanel;
import util.Arrays;
import util.Map;
import util.concurrent.ConcurrentHashMap;
import util.Random;

class Tetris {

    var game = new Game();
    var strategy;

    const BOARD_CORNER_X = 300;
    const BOARD_CORNER_Y = 50;

    const keyboard = new GameController();
    var lastIteration = System.currentTimeMillis();

    static const PIECE_WIDTH = 20;

    new() {
        var container = new JFrame("Tetris");
        var canvas = new Canvas();
        var panel = container.getContentPane();
        panel.setPreferredSize(new Dimension(800, 600));
        panel.setLayout(null);

        canvas.setBounds(0, 0, 800, 600);
        panel.add(canvas);
        canvas.setIgnoreRepaint(true);

        container.pack();
        container.setResizable(false);
        container.setVisible(true);

//        container.addWindowListener(new WindowAdapter() {
//            public void windowClosing(WindowEvent e) {
//                System.exit(0);
//            }
//        });

        canvas.addKeyListener(keyboard);
        canvas.requestFocus();

        canvas.createBufferStrategy(2);
        strategy = canvas.getBufferStrategy();
    }

    gameLoop() {
        loop {
            if (keyboard.newGame()) {
                game = new Game();
                game.startGame();
            }
            if (game.isPlaying()) {

                if (!game.isPaused()) {
                    tetrisLoop();
                }
                if (keyboard.pauseGame()) {
                    game.pauseGame();
                }
                try {
                    Thread.sleep(20);
                } catch (e) { 
                   e.printStackTrace();
                }
            }
            draw();
        }
    }

    tetrisLoop() {
        if (game.isDropping()) {
            game.moveDown();
        } else if (System.currentTimeMillis() - lastIteration >= game.getIterationDelay()) {
            game.moveDown();
            lastIteration = System.currentTimeMillis();
        }
        if (keyboard.rotate()) {
            game.rotate();
        } else if (keyboard.left()) {
            game.moveLeft();
        } else if (keyboard.right()) {
            game.moveRight();
        } else if (keyboard.drop()) {
            game.drop();
        }
    }

    draw() {
        var g = getGameGraphics();
        drawEmptyBoard(g);
        drawHelpBox(g);
        drawPiecePreviewBox(g);

        if (game.isPlaying()) {
            drawCells(g);
            drawPiecePreview(g, game.getNextPiece().getType());

            if (game.isPaused()) {
                drawGamePaused(g);
            }
        }

        if (game.isGameOver()) {
            drawCells(g);
            drawGameOver(g);
        }
        
        drawStatus(g);
        drawPlayTetris(g);

        g.dispose();
        strategy.show();
    }

    getGameGraphics() {
        return strategy.getDrawGraphics();
    }

    drawCells(g) {
        var cells = game.getBoardCells();
        for (var i = 0; i < 10; i++) {
            for (var j = 0; j < 20; j++) {
                drawBlock(g, BOARD_CORNER_X + i * 20, BOARD_CORNER_Y + (19 - j) * 20, getBoardCellColor(cells[i][j]));
            }
        }
    }

    drawEmptyBoard(g) {
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, 800, 600);
        g.setColor(Color.GRAY);
        g.drawRect(BOARD_CORNER_X - 1, BOARD_CORNER_Y - 1, 10 * PIECE_WIDTH + 2, 20 * PIECE_WIDTH + 2);
    }

    drawStatus(g) {
        g.setFont(new Font("Dialog", Font.PLAIN, 16));
        g.setColor(Color.RED);
        g.drawString(getLevel(), 10, 20);
        g.drawString(getLines(), 10, 40);
        g.drawString(getScore(), 20, 80);
    }

    drawGameOver(g) {
        var font = new Font("Dialog", Font.PLAIN, 16);
        g.setFont(font);
        g.setColor(Color.RED);
        g.drawString("GAME OVER", 350, 550);
    }

    drawGamePaused(g) {
        var font = new Font("Dialog", Font.PLAIN, 16);
        g.setFont(font);
        g.setColor(Color.YELLOW);
        g.drawString("GAME PAUSED", 350, 550);
    }


    drawPlayTetris(g) {
        var font = new Font("Dialog", Font.PLAIN, 16);
        g.setFont(font);
        g.setColor(Color.RED);
        g.drawString("Play TETRIS !", 350, 500);
    }

    getLevel() {
        return String.format("Your level: %1s", game.getLevel());
    }

    getLines() {
        return String.format("Full lines: %1s", game.getLines());
    }

    getScore() {
        return String.format("Score     %1s", game.getTotalScore());
    }

    drawPiecePreviewBox(g) {
        g.setFont(new Font("Dialog", Font.PLAIN, 16));
        g.setColor(Color.RED);
        g.drawString("Next:", 50, 420);
    }

    drawHelpBox(g) {
        g.setFont(new Font("Dialog", Font.PLAIN, 16));
        g.setColor(Color.RED);
        g.drawString("H E L P", 50, 140);
        g.drawString("F1: Pause Game", 10, 160);
        g.drawString("F2: New Game", 10, 180);
        g.drawString("UP: Rotate", 10, 200);
        g.drawString("ARROWS: Move left/right", 10, 220);
        g.drawString("SPACE: Drop", 10, 240);
    }

    drawPiecePreview(g, type) {
        for (var p in type.getPoints()) {
            drawBlock(g, 60 + p.x * PIECE_WIDTH, 380 + (3 - p.y) * 20, getPieceColor(type));
        }
    }

    getBoardCellColor(boardCell) {
        if (boardCell.isEmpty()) {
            return Color.BLACK;
        }
        return getPieceColor(boardCell.getPieceType());
    }

    getPieceColor(pieceType) {
        if(pieceType == PieceType.I){
            return Color.RED;
        }
        if(pieceType == PieceType.J) {
            return Color.GRAY;
        }
        if(pieceType == PieceType.L) {
            return Color.CYAN;
       }
        if(pieceType == PieceType.O) {
            return Color.BLUE;
        }
        if(pieceType == PieceType.S) {
            return Color.GREEN;
        }
        return Color.MAGENTA;
    }

    drawBlock(g, x, y, color) {
        g.setColor(color);
        g.fillRect(x, y, PIECE_WIDTH, PIECE_WIDTH);
        g.drawRect(x, y, PIECE_WIDTH, PIECE_WIDTH);
    }

}

function start() {
   var t = new Tetris();
   
   try {
      t.gameLoop();
   } catch(e) {
      e.printStackTrace();
   }
}

start();
