import util.regex.Pattern;

let lines = File("C:\\Work\\development\\tern-lang\\tern\\README.md").readLines();
let source = LinkedList<String>(lines);
let out = File("C:\\Work\\development\\tern-lang\\tern-site\\tern-lang.org\\index.html");
let file = FileOutputStream(out);
let stream = PrintStream(file);

stream.println("<html>");
stream.println("<head>");
stream.println("  <link rel='stylesheet' href='css/style.css'>");
stream.println("  <meta property='og:url' content='http://tern-lang.org/'/>");
stream.println("  <meta property='og:type' content='website'/>");
stream.println("  <meta property='og:description' content='Tern Programming Language' />");
stream.println("  <meta property='og:site_name' content='Tern Programming Language' />");
stream.println("  <meta property='og:image' content='http://tern-lang.org/img/tern.png' />");
stream.println("  <title>Tern Programming Language</title>");
stream.println("</head>");
stream.println("<body>");
// https://codepo8.github.io/css-fork-on-github-ribbon/
stream.println(`<style>#forkongithub a{background:#666666;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}#forkongithub a:hover{background:#ffb600;color:#fff;}#forkongithub a::before,#forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}#forkongithub a::after{bottom:1px;top:auto;}@media screen and (min-width:800px){#forkongithub{position:absolute;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:60px;right:-60px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:0px 0px 0px rgba(0,0,0,0.8);}}</style><span id="forkongithub"><a href="https://github.com/tern-lang/tern">Fork me on GitHub</a></span>`);

process(lines).stream().forEach(e -> {
   e.render("", stream);
});

stream.println("</body>");
stream.println("</html>");
stream.close();
   
func process(source: List<String>): List<HtmlElement> {
   let elements: List<HtmlElement> = [];
   
   while(!source.isEmpty()) {
      let next = source.get(0);
      
      if(next.trim().startsWith("![")) {
         processImage(source, elements);
      } else if(next.trim().startsWith("[![")) {
         processVideo(source, elements);         
      } else if(next.trim().startsWith("[")) {
         processLink(source, elements);   
      } else if(next.startsWith("#")) {
         processHeader(source, elements);
      } else if(next.trim().startsWith("```")) {
         processCode(source, elements);
      } else if(next.trim().startsWith("*")) {
         processBulletList(source, elements);
      } else if(next.trim().startsWith("|")) {
         processTable(source, elements);   
      } else if(next.trim().isEmpty()) {
         processParagraph(source, elements);
      } else {
         source.remove(0);
      }
   }
   return elements;
}   

func processParagraph(text: List<String>, elements: List<HtmlElement>) {
   let paragraph = ParagraphElement();
   
   text.remove(0);
   
   while(!text.isEmpty()) {
      let line = text.get(0);
      
      if(line.trim().isEmpty()) {
         break;
      }
      let char = line.trim().charAt(0).toString();
      
      if("*[`!#|".contains(char)) {
         break;
      }
      let element = TextElement(line);
      
      paragraph.addElement(element);
      text.remove(0);
   }
   elements.add(paragraph);
}

func processTable(text: List<String>, elements: List<HtmlElement>) {
   let paragraph = ParagraphElement();
   let columns = text.remove(0).trim().substring(1).split("\\s*\\|\\s*");
   let table = TableElement(columns);
   
   text.remove(0); // remove the +----------+
   
   while(!text.isEmpty()) {
      let line = text.get(0);
      
      if(!line.trim().startsWith("|")) {
         break;
      }
      let values = line.trim().substring(1).split("\\s*\\|\\s*");
      let element = TableRowElement(values);
      
      table.addElement(element);
      text.remove(0);
   }
   elements.add(table);
}

func processBulletList(source: List<String>, elements: List<HtmlElement>) {
   let previous = BulletElement(null, null, "");
   let stack = Stack();
   let root = previous;
   
   stack.push(previous);
   
   while(!source.isEmpty()) {
      let next = source.get(0);
      
      if(next.trim().startsWith("*")) {
         let pattern = Pattern.compile("^(\\s*)\\*\\s*\\[(.*)\\]\\(#(.*)\\)\\s*");
         let matcher = pattern.matcher(next);    
         
         if(!matcher.matches()) {
            throw new IllegalStateException("Could not match list ${next}");
         }
         let indent = matcher.group(1);
         let title = matcher.group(2).trim();
         let anchor = matcher.group(3).trim();
         
         if(indent.length == previous.indent.length) {
            // we are working on the same list
            let element = BulletElement(title, anchor, indent);
            let parent = stack.peek();
            
            parent.addElement(element);
            previous = element;
         } else if(indent.length < previous.indent.length) {
            // we go back to the parent
            let element = BulletElement(title, anchor, indent);
            let current = stack.pop();
            let parent = stack.peek();
            
            parent.addElement(element);
            previous = element;
         } else {
            // why does this not become the current???
            // create a new child by indenting
            let element = BulletElement(title, anchor, indent);
            
            stack.push(previous);
            previous.addElement(element);
            previous = element;
         }
      } else {
         break;
      }
      source.remove(0);
   }
   elements.add(root);
}

func processVideo(source: List<String>, elements: List<HtmlElement>) {
   let line = source.remove(0);
   let pattern = Pattern.compile("\\[!\\[(.*)\\]\\((.*)\\)\\]\\((.*)\\)");
   let matcher = pattern.matcher(line);
   
   if(!matcher.matches()) {
      throw new IllegalStateException("Invalid video '${line}'");
   }
   let title = matcher.group(1);
   let image = matcher.group(2);
   let video = matcher.group(3);
   let element = VideoElement(video, image, title);
   
   elements.add(element);
}

func processImage(source: List<String>, elements: List<HtmlElement>) {
   let line = source.remove(0);
   let pattern = Pattern.compile("!\\[(.*)\\]\\((.*)\\)");
   let matcher = pattern.matcher(line);
   
   if(!matcher.matches()) {
      throw new IllegalStateException("Invalid image '${line}'");
   }
   let text = matcher.group(1);
   let link = matcher.group(2);
   let element = ImageElement(text, link);
   
   elements.add(element);
}

func processLink(source: List<String>, elements: List<HtmlElement>) {
   let line = source.remove(0);
   let pattern = Pattern.compile("\\[(.*)\\]\\((.*)\\)");
   let matcher = pattern.matcher(line);
   
   if(!matcher.matches()) {
      throw new IllegalStateException("Invalid link '${line}'");
   }
   let text = matcher.group(1);
   let link = matcher.group(2);
   let element = LinkElement(text, link);
   
   elements.add(element);
}

func processHeader(source: List<String>, elements: List<HtmlElement>) {
   let line = source.remove(0);
   let pattern = Pattern.compile("(#+)\\s+(.+)");
   let matcher = pattern.matcher(line);
   
   if(!matcher.matches()) {
      throw new IllegalStateException("Invalid header '${line}'");
   }
   let size = matcher.group(1).length();
   let text = matcher.group(2).trim();
   let element = HeaderElement(text, size);
   
   elements.add(element);
}

func processCode(source: List<String>, elements: List<HtmlElement>) {
   let line = source.remove(0);
   let pattern = Pattern.compile("```(.*)");
   let matcher = pattern.matcher(line);
   
   if(!matcher.matches()) {
      throw new IllegalStateException("Invalid header '${line}'");
   }
   let lang = matcher.group(1);
   let builder = StringBuilder();
   
   while(!source.isEmpty()) {
      let next = source.remove(0);
      
      if(next.startsWith("```")) {
         break;
      }
      builder.append(next);
      builder.append("\n");
   }
   let code = builder.toString();
   let element = CodeElement(code, lang);
   
   elements.add(element);
}
   
   
abstract class HtmlElement {
   const elements;
   
   new() {
      this.elements = [];
   }
   
   addElement(e: HtmlElement) {
      if(e) {
         elements.add(e);
      }
   }
   
   abstract render(indent: String, b: PrintStream);
}

class TextElement extends HtmlElement {

   const text;
   
   new(text) {
      this.text = text;
   }
   
   override render(indent: String, b: PrintStream){
      let builder = StringBuilder();
      let original = text;
      
      loop {
         if(original.matches(".*\\[.*\\]\\(.*\\).*")) {
            let length = original.length();
            let start = original.indexOf("[");
            let end = original.indexOf(")", start);
            
            while(end < length) {
               let char = original.charAt(end);
               
               if(char != ')') {
                  break;
               }
               end++;
            }
            let prefix = original.substring(0, start);
            let link = original.substring(start, end);
            let pattern = Pattern.compile("\\[(.*)\\]\\((.*)\\)");
            let matcher = pattern.matcher(link);
            
            if(!matcher.matches()) {
               throw new IllegalStateException("Invalid link ${link}");
            }
            let display = matcher.group(1);
            let address = matcher.group(2);
            
            builder.append(prefix);
            builder.append("<a href='${address}'>${display}</a>");
            
            original = original.substring(end, length);
         } else if(original.matches(".*```.*```.*")) {
            let length = original.length();
            let start = original.indexOf("```");
            let end = original.indexOf("```", start + 1);
            let prefix = original.substring(0, start);
            let code = original.substring(start, end + 3);
            let pattern = Pattern.compile("```(.*)```");
            let matcher = pattern.matcher(code);
            
            if(!matcher.matches()) {
               throw new IllegalStateException("Invalid code ${code}");
            }
            let source = matcher.group(1);
            
            builder.append(prefix);
            builder.append("<span style='font-family: monospace'>${source}</span>");
            
            original = original.substring(end + 3, length);
         } else {
            builder.append(original);
            break;
         }
      }
      b.print("${indent}${builder}");
   }
   
}

class VideoElement extends HtmlElement {

   const video;
   const image;
   const title;
   
   new(video, image, title) {
      this.video = video;
      this.image = image;
      this.title = title;
   }

   override render(indent: String, b: PrintStream) {
      b.print("${indent}<p>");
      b.print("<a href='${video}' rel='nofollow'>");
      b.print("<img alt='${title}' src='${image}' style='max-width:100%;'>");
      b.print("</a>");
      b.print("</p>");

   }
}

class TableElement extends HtmlElement {

   const titles;
   
   new(titles) {
      this.titles = titles;
   }
   
   override render(indent: String, b: PrintStream) {
      b.println("${indent}<table border='0'>");
      
      for(title in titles) {
         b.println("${indent}    <th>${title}</th>");
      }
      for(element in elements) {
         element.render("${indent}   ", b);
      }
      b.println("${indent}</table>");
   }
}

class TableRowElement extends HtmlElement {

   const values;
   
   new(values) {
      this.values = values;
   }
   
   override render(indent: String, b: PrintStream) {
      b.println("${indent}<tr>");
      
      for(value in values){
         b.println("${indent}   <td>${value}</td>");
      }
      b.println("${indent}</tr>");
   }
}

class BulletElement extends HtmlElement {

   const text;
   const anchor;
   const indent;
   
   new(text, anchor, indent) {
      this.text = text;
      this.anchor = anchor;
      this.indent = indent;
   }
   
   override render(i: String, b: PrintStream) {
      if(text) {
         b.print("${i}${indent}<li><a href='#${anchor}'>${text}</a>");
      }
      if(!elements.isEmpty()) {
         b.println();
         b.println("${i}${indent}<ul>");
      
         for(entry in elements) {
            entry.render("${i}${indent}", b);
         }
         b.println("${i}${indent}</ul>");
         b.println("${i}${indent}</li>");
      } else {
         if(text) {
            b.println("</li>");
         }
      }
   }
}

class LinkElement extends HtmlElement {
   
   const text;
   const link;
   
   new(text, link) {
      this.text = text;
      this.link = link;
   }
   
   override render(indent: String, b: PrintStream) {
      b.print("${indent}<a href='${link}'>${text}</a>");
   }
}

class ImageElement extends HtmlElement {
   
   const text;
   const link;
   
   new(text, link) {
      this.text = text;
      this.link = link;
   }
   
   override render(indent: String, b: PrintStream) {
      b.println("${indent}<img src='${link}' alt='${text}'>");
   }
}

class HeaderElement extends HtmlElement {

   const size;
   const text;
   
   new(text, size) {
      this.text = text;
      this.size = size;
   }
   
   override render(indent: String, b: PrintStream) {
      b.println("${indent}<h${size}><a id='${text.toLowerCase().replace(' ', '-')}'></a>${text}</h${size}>");
   }
}

class CodeElement extends HtmlElement {

   const lang;
   const code;
   
   new(code, lang) {
      this.code = code;
      this.lang = lang;
   }
   
   override render(indent: String, b: PrintStream) {
      b.print("${indent}<pre>${code}</pre>");
   }
}
   
class ParagraphElement extends HtmlElement {
   
   override render(indent: String, b: PrintStream) {
      b.print("${indent}<p>");
      
      for(element in elements) {
         element.render(indent, b);
      }
      b.println("${indent}</p>");
   }
}
