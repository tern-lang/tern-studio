import net.Socket;
import util.concurrent.TimeUnit;

class TickTockClient {

   const averager;
   const socket;

   new(host, port) {
      this.socket = Socket(host, port);
      this.averager = Averager(10);
   }

   start(listener: (accuracy)) {
      const input = socket.getInputStream();
      const output = socket.getOutputStream();
      const reader = DataInputStream(input);
      const writer = DataOutputStream(output);

      writer.writeLong(0);

      loop {
         const remoteTime = reader.readLong(); // read remote time
         const accuracy = reader.readLong(); // read remote time
         const localTime = System.currentTimeMillis(); // current local time
         const currentDiff = Math.abs(remoteTime - localTime); // difference in time
         const averageDiff = averager.update(currentDiff);
         const pingTime = (localTime - averageDiff) + 1000;
         
         if(averageDiff > 0) {
            const sleep = Math.max(0, averageDiff - 20);

            if(sleep > 0) {
               Thread.sleep(sleep, 0); // sleep until 20 ms before time
            }
         }
         loop {
            const currentTime = System.currentTimeMillis();

            if(currentTime >= pingTime) { // spin until difference is exact
               writer.writeLong(remoteTime + 1000);
               break;
            }
         }
         listener(accuracy); // report on accuracy should be async
      }
   }
   
   class Averager {
   
      const queue;
      const capacity;
      const samples;
      
      new(capacity) {
         this.queue = PriorityQueue();
         this.samples = ArrayDeque(capacity);
         this.capacity = capacity;
      }
   
      update(sample) {
         if(samples.length >= capacity) {
            samples.poll();
         }
         samples.offer(sample);
         
         return average();
      }
      
      average() {
         let ignore = Math.round(samples.length * 0.1);
         let count = samples.length - (ignore * 2);
         let total = 0;
         
         queue.clear();
         queue.addAll(samples);
         
         for(i in 0 to ignore - 1) { // remove lowest 10%
            queue.poll();
         }
         for(i in 0 to count - 1) { // ignore highest 10% 
            total += queue.poll();
         }
         return total / count;
      
      }
   }
}
