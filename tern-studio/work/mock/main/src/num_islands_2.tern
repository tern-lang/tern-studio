
assert numIslands(2, 2, [[0,0], [1,1], [0,1]]) == [1,2,1];
assert numIslands(3, 3, [[0,0], [0,1], [1,2], [2,1]]) == [1,1,2,3];

func numIslands(m, n, positions) {
   let map = indexLocations(m, n);
   let counts = [];
   
   for(let position in positions) {
      let key = "${position[0]}.${position[1]}";
      let location = map[key];
      let beside = Direction.adjacent(location, map);
       
      location.nodes.add(location);
      location.value = 1;

      for(let other in beside) {
         location.combine(beside);
      }
      let count = countIslands(map);
      counts.add(count);
   }
   println(counts);
   return counts;
}

func countIslands(map){
   let done = {};
   let count = 0;
   
   for(let entry in map) {
      let location = entry.value;

      if(location.value != 0) {
         if(done.add(location)) {
            done.addAll(location.nodes);
            count++;
         }
      }
   }
   return count;
}

func indexLocations(m, n) {
   let locations = {:};
   
   for(let i = 0; i < m; i++) {
      for(let j = 0; j < n; j++){
         let location = Location(i, j);
         locations[location.key] = location;
      }
   }
   return locations;
}

class Location {

   let nodes: Set<Location>;
   let value;   
   let row;
   let col;
   
   new(row, col){
      this.nodes = {};
      this.row = row;
      this.col = col;
      this.value = 0;
   }
   
   combine(location){
      nodes.add(location);
      location.nodes.add(this);
   }

   getKey(){
      return "${row}.${col}";
   }
   
   override toString() {
      return "${row}.${col}=${value}";
   }
}

class Direction {
   static const LEFT = Direction(0, -1);
   static const RIGHT = Direction(0, 1);
   static const UP = Direction(-1, 0);
   static const DOWN = Direction(1, 0);
   static const ALL = [LEFT, RIGHT, UP, DOWN];
   
   const row;
   const col;
   
   new(row, col) {
      this.row = row;
      this.col = col;
   }
   
   next(location, map): Location {
      let nextRow = row + location.row;
      let nextCol = col + location.col;
      let key = "${nextRow}.${nextCol}";
      let next = map[key];
 
      if(next != null && next.value != 0) {
         return next;
      }
      return null;
   }
   
   static adjacent(location, map): List<Location> {
      let beside = [];
      
      for(let direction in ALL) {
         let next = direction.next(location, map);
         
         if(next != null) {   
            beside.add(next);
         }
      }
      return beside;
   }
}